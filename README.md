# Betta-Bank

---

**Мобильное приложение дистанционного банковского обслуживания клиентов (СДБО)**

Система позволит клиентам:

* Управлять своими банковскими счетами
* Совершать платежи по реквизитам
* Совершать переводы между вкладами и банковскими картами
* Осуществлять переводы средств клиентам Банка
* Осуществлять обмен валюты
* Просматривать проведенные транзакции
* Оформлять новые банковские продукты
* Получить информацию о банковских продуктах (кредитах, депозитах, картах)

В будущем также планируется подключение функциональности для работы с юридическими лицами, которая будет позволять клиентам:

* Проводить платежные исполнения в валюте онлайн
* Отслеживать историю финансовых операций и получать выписку транзакций по счетам
* Настраивать автоматические шаблоны для платежных документов
* Производить обмен валюты

---

Оглавление

1. [Архитектурный паттерн и библиотеки](#mvvm-c)
2. [Code Style. Общие положения](#codestyle)
    1. [Отступы](#indent)
    2. [Использование `self`](#self)
    3. [Объявление и вызов функций](#func)
    4. [Замыкания](#closure)
    5. [Переменные](#var)
    6. [Названия](#naming)
        1. [Классы и структуры](#class-naming)
        2. [Протоколы](#protocol-naming)
        3. [Функции](#func-naming)
        4. [Переменные и константы](#var-naming)
3. [Storyboard / XIB](#storyboard)
4. [Правила, способствующие ускорению компиляции](#compiler-rules)
5. [Правила именования методов](#func-rules)
6. [Описание SwiftLint](#swiftlint)

## <a name="mvvm-c"></a> Архитектурный паттерн и библиотеки

Используется архитектурный паттерн MVVM-C, фреймворки UIKit и Combine

Внешние библиотеки устанавливаются через [CocoaPods](https://cocoapods.org):

* [SnapKit](https://cocoapods.org/pods/SnapKit)
* [SwiftLint](https://cocoapods.org/pods/SwiftLint)

Для создания новых экранов применяется готовый шаблон:

* Шаблон находится в develop ветке по адресу `Template/MVVM.zip`> 
* Установка шаблона:
    * Распаковываете архив на рабочем столе, далее в терминале:

```
mkdir ~/Library/Developer/Xcode/Templates
cp -r ~/Desktop/MVVM ~/Library/Developer/Xcode/Templates/
```

Сборка проекта:

* Осуществляется с помощью [XcodeGen](https://github.com/yonaskolb/XcodeGen)
* В общем случае после клонирования запускать `xcodegen && pod install`

## <a name="codestyle"></a> Code Style. Общие положения

Целью данного раздела является улучшение и унификация структуры кода в помощь действующим разработчикам на проекте, а также для вновь прибывших. Данный раздел основан на [Aston Code Conventions](https://nextcloud.andersenlab.dev/index.php/s/ePp9gPTaj4BNWiH).

-
### <a name="indent"></a> Отступы
-

* Отступы между областями видимости (классы и расширения) - одна пустая строка
* Отступы между свойствами / методами / инициализаторами - также одна пустая строка
* Отступы до и после `// MARK: - ` одна пустая строка

* Открывающие фигурные скобки классов, методов и операторов остаются на той же строке, закрывающие - на отдельной новой строке. [Исключение - методы, объединенные в цепочку](#methodchain)

```
doSomething() {
    // ...
}
```

* Отступы внутри методов должны отражать разделение логики и облегчать ее восприятие. Но если отступов получается слишком много, то это значит, что метод необходимо дробить и выносить функциональность.
* Перед двоеточием не должно быть пробела, а после - один пробел. Исключения - это тернарный оператор ` ? : `, пустой словарь `[:]` и синтаксис `#selector` для безымянных параметров `(_:)`.

-
### <a name="self"></a> Использование `self`
-

Избегайте использования `self` там, где этого не требуется. Используйте только для разделения свойств класса и аргументов инициализаторов, а также в замыканиях (как нас обязывает делать компилятор)

-
### <a name="func"></a> Объявление и вызов функций
-

Небольшие функции должны быть описаны одной строкой:

```
func foo(arg: Int) -> Double {
    // ...
}
```

Для функций с более чем двумя аргументами следует переносить строку после каждого аргумента для удобства восприятия:

```
func foo(arg1: Int,
         arg2: Double,
         arg3: String) -> String {
    // ...
}
```

То же касается и вызова функций:

```
someFunction(
    arg1: 1,
    arg2: 2.0,
    arg3: "3"
)
```

-
### <a name="closure"></a> Замыкания
-

Используйте синтаксис последующего замыкания только в том случае, если в конце списка аргументов есть всего один параметр выражения замыкания. Давайте понятные имена параметрам замыкания:

```
UIView.animateWithDuration(1) {
    self.myView.alpha = 0
}

UIView.animate(
    withDuration: 1,
    animations: {
        self.view.alpha = 0
    },
    
    completion: { finished in
        self.view.removeFromSuperview()
    }
)
```

В случае, когда вызываемая функция имеет несколько параметров и запись получается слишком длинной, помещайте замыкание в переменную:

```
let completion: (Response, Error) = { [weak output] response, error in
    guard let output = output else { return }

    if let error = error {
        output.didReceiveError(error)
    } else if let payload = response?.payload {
        output.didReceiveResponse(payload)
    }
}

API
    .configure()
    .getUsingGET(
        id: id,
        field1: field1,
        field2: field2,
        completion: completion
)
```

<a name="methodchain"></a>Методы, объединенные в цепочку должны начинаться с новой строки, фигурные скобки по возможности остаются в одной строке с именем функции:

```
let value = numbers
    .map { $0 * 2 }
    .filter { $0 > 50 }
    .map { $0 + 10 }
```

-
### <a name="var"></a> Переменные
-

Не указывайте тип переменной, если он и так понятен при объявлении. И наоборот указывайте, если тип может противоречить первоначальному смыслу:

```
let width = 120 // Int
let widthString = String(width) // String
```

-
### <a name="naming"></a>Названия
-

#### <a name="class-naming"></a> Классы и структуры

* Используйте структуры для моделей данных
* По возможности, избегайте наследования классов
* Имя класса или структуры должно полностью отражать область его применения. Не бойтесь использовать длинные имена.
* Соблюдайте принципы SOLID

#### <a name="protocol-naming"></a> Протоколы

* Имя протокола не должно содержать `interface` и не должно начинаться с буквы `I`
* Согласно рекомендациям из Apple's API Design Guidelines, имена протоколов, описывающих возможности, должны быть существительными, заканчивающимися на -able, -ible. Например `Codable`, `ExpressibleBy...`
* Имена протоколов, которые являются обычным контрактом между объектами должны заканчиваться словом Protocol. Пример - делегаты в архитектурах MVP / VIPER / Clean

#### <a name="func-naming"></a> Функции

* Каждая функция должна отвечать за какую-то одну задачу
* Название должно полностью соответствовать тому, за что функция отвечает.
* Имя функции должно начинаться с глагола.
* Согласно camelCase, первое слово начинается со строчной буквы, все последующие с заглавной.

Примеры:

Функция, которая выполняет задачу:
`func move(to point: CGPoint)` - так надо
`func moveToPoint(_ point: CGPoint)` - так не надо

Функция, которая возвращает объект:
`func getItem() -> Item`

Функции, которые занимаются созданием объектов:
`func makeItem(withTitle title: String) -> Item`
`func makeItem(title: String) -> Item`

Плохой пример - не понятно, что именно передается в качестве аргумента:
`func makeItem(_ title: String) -> Item`

Функция, которая получает объект из хранилища:
`func fetchItem() -> Item`

Функция, которая делает запрос:
`func requestItem(completion: @escaping (Result) -> Void)`

#### <a name="var-naming"></a> Переменные и константы

Переменные и константы должны быть названы именами существительными, написанными в соответствии с camelCase:

```
var imageLoader: ImageLoader
let defaultAnimationDuration: TimeInterval = 0.5
```

---

### <a name="storyboard"></a> Storyboard / XIB

Не используйте. Абсолютно вся верстка должна быть выполнена кодом.

---

## <a name="compiler-rules"></a> Правила, способствующие ускорению компиляции

|Правило|Плохой пример|Хороший пример|Влияние на время компиляции|
|-------|-------------|--------------|---------------------------|
|Не сравнивайте переменную с nil|`optVar == nil`|`optVar.isNil`|низкое|
|Не используйте конкатенацию String с + или +=|`str + "!"`|`str.appending("1")` или `"\(str)!"`|среднее|
|Не используйте мат. операторы с переменными и литералами|`let sum = count + 1`|`let sum = count.plus(1)`|низкое-среднее|
|Не переводите String в Int через конструктор|`Int("1")`|`"1".toInt`|низкое-среднее|
|Не используйте optional chaining с оператором объединения|`optVar?.foo ?? ""`|`(optVar?.foo) ?? ""`|низкое|
|Не используйте init нарямую|`.init("1")`|`Foo("1")`|низкое-среднее|
|Не сравнивайте строки используя ==|`"1" == "2"`|`"1".isEqual(to "2")`|низкое-среднее|
|Не используйте оператор + для добавления к массиву|`let arr = [1] + [2]`|`let arr = [1].append(2)`|низкое-среднее|
|Не сравнивайте логические значения явно|`if a == true {}`|`if a {}`|низкое|
|Объявляйте тип переменной в сложных выражениях|`let a = Int("2") + 4`|`let a: Int = Int("2") + 4`|низкое-среднее|

## <a name="func-rules"></a> Правила именования методов

|Действие|Слово|Пример имени метода|
|--------|-----|------|
|Получить данные из сети|request|`requestData`|
|Получить данные локально|get|`getCachedData`|
|Получить данные от сервиса|obtain|`obtainData`|
|Сохранить данные локально|save|`saveData`|
|Фабричный метод|make|`makeStringBuilder`|
|Передать данные для аналитики|log|`logScreenShown`|
|Настроить модель для view|configure|`configureMeetingRoomsList`|
|Делегирование открытия экрана координатору|ask to show|`output.didAskToMeetingRoom`|
|Обработка чего-либо вне замыкания|handle|`handleMeetingRoomsListResponse`|
|Метод содержащий вычисления|calculate или measure|`calculateHeight`|
|Метод который делает что-то исходя из условий|[do something] if needed|`showMeetingRoomsListIfNeeded`|

## <a name="swiftlint"></a> Описание SwiftLint

SwiftLint - это инструмент для соблюдения стиля и соглашений Swift.

Поддержание чистоты и соответствия кодовой базы — действительно сложная задача, особенно при работе в команде.

В текущем проекте также применены ряд правил уже имеющиеся в SwiftLint, такие как `force_unwrap`, `body_length` и так далее. Вместе с тем прописаны дополнительные правила код-стайла.

Данные правила указаны в скрытом файле с названием .swiftlint.yml, находящемся в папке с проектом. В данном файле можно ознакомиться с дополнительно прописанными правилами, написанными  с помощью регулярных выражений и отсутствующие в нативной версии SwiftLint, также можно ознакомиться с теми правилами которые были отключены или напротив, включены для поиска отображения определенных кейсов.